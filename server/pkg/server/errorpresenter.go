package server

import (
	"context"
	"errors"
	"github.com/99designs/gqlgen/graphql"
	"github.com/sirupsen/logrus"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"server/pkg/model"
	"server/pkg/typederrors"
)

type TypedError interface {
	error
	ErrorType() model.ErrorType
}

// presentTypedError is a helper function that converts a TypedError to *gqlerror.Error
// and adds the error type to the extensions field
func presentTypedError(ctx context.Context, typedErr TypedError) *gqlerror.Error {
	presentedError := graphql.DefaultErrorPresenter(ctx, typedErr)
	if presentedError.Extensions == nil {
		presentedError.Extensions = make(map[string]interface{})
	}
	presentedError.Extensions["errorType"] = typedErr.ErrorType()
	return presentedError
}

func GqlErrorPresenter(ctx context.Context, err error) *gqlerror.Error {
	var typedError TypedError
	isTypedError := errors.As(err, &typedError)
	if isTypedError {
		return presentTypedError(ctx, typedError)
	}
	// New code for masking sensitive error messages starts here
	var gqlError *gqlerror.Error
	if errors.As(err, &gqlError) && errors.Unwrap(gqlError) == nil {
		// It's a GraphQL schema validation / parsing error generated by the server itself,
		// error message should not be masked
		return graphql.DefaultErrorPresenter(ctx, err)
	}
	// Log original error and return InternalServerError instead
	logrus.WithError(err).Error("Custom GraphQL error presenter got an unexpected error")
	return presentTypedError(ctx, typederrors.InternalServerError("internal server error").(TypedError))
}
